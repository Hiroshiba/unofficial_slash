A Spectral Energy Distance
for Parallel Speech Synthesis
Alexey A. Gritsenko∗† Tim Salimans∗ Rianne van den Berg
Jasper Snoek Nal Kalchbrenner
{agritsenko,salimans,riannevdberg,jsnoek,nalk}@google.com
Google Research
Abstract
Speech synthesis is an important practical generative modeling problem that has
seen great progress over the last few years, with likelihood-based autoregressive
neural models now outperforming traditional concatenative systems. A downside
of such autoregressive models is that they require executing tens of thousands
of sequential operations per second of generated audio, making them ill-suited
for deployment on specialized deep learning hardware. Here, we propose a new
learning method that allows us to train highly parallel models of speech, without
requiring access to an analytical likelihood function. Our approach is based on
a generalized energy distance between the distributions of the generated and real
audio. This spectral energy distance is a proper scoring rule with respect to the
distribution over magnitude-spectrograms of the generated waveform audio and
offers statistical consistency guarantees. The distance can be calculated from
minibatches without bias, and does not involve adversarial learning, yielding a
stable and consistent method for training implicit generative models. Empirically,
we achieve state-of-the-art generation quality among implicit generative models, as
judged by the recently-proposed cFDSD metric. When combining our method with
adversarial techniques, we also improve upon the recently-proposed GAN-TTS
model in terms of Mean Opinion Score as judged by trained human evaluators.
1 Introduction
Text-to-speech synthesis (TTS) has seen great advances in recent years, with neural network-based
methods now significantly outperforming traditional concatenative and statistical parametric approaches [39, 35]. While autoregressive models such as WaveNet [35] or WaveRNN [15] constitute
the current state of the art in speech synthesis, their sequential nature is often seen as a drawback.
They generate only a single sample at a time, and since audio is typically sampled at a frequency of
18kHz to 44kHz this means that tens of thousands of sequential steps are necessary for generating
a single second of audio. The sequential nature of these models makes them ill-suited for use with
modern deep learning hardware such as GPUs and TPUs that are built around parallelism.
At the same time, parallel speech generation remains challenging. Existing likelihood-based models
either rely on elaborate distillation approaches [27, 36], or require large models and long training
times [29, 22]. Recent GAN-based methods provide a promising alternative to likelihood-based
methods for TTS [3, 22]. Although they do not yet match the speech quality of autoregressive models,
they are efficient to train and employ fully-convolutional architectures, allowing for efficient parallel
generation. However, due to their reliance on adversarial training, they can be difficult to train.
∗Equal contribution. † Work completed as a Google AI resident.
34th Conference on Neural Information Processing Systems (NeurIPS 2020), Vancouver, Canada.
arXiv:2008.01160v2 [eess.AS] 23 Oct 2020
To address these limitations we propose a new training method based on the generalized energy
distance [10, 32, 33], which enables the learning of implicit density models without the use of
adversarial training or requiring a tractable likelihood. Our method minimizes a multi-resolution
spectrogram loss similar to previous works [37, 38, 9, 6], but includes an additional repulsive term
that encourages diverse samples and provides a statistical consistency guarantee. As a result, our
models enjoy stable training and rapid convergence, achieving state-of-the-art speech quality among
implicit density models.
In addition to demonstrating our proposed energy distance on the speech model of Binkowski ´
et al. [3], we further propose a new model for generating audio using an efficient overlap-add
upsampling module. The new model is faster to run, while still producing high quality speech.
Finally, we show that our proposed energy distance can be combined with GAN-based learning,
further improving on either individual technique. An open source implementation of our generalized
energy distance is available at https://github.com/google-research/google-research/
tree/master/ged_tts.
2 Related work on speech synthesis
Our task of interest is synthesizing speech waveforms conditional on intermediate representations
such as linguistic and pitch features, as usually provided by a separate model in a 2-step process.
Here we briefly review the related literature on this problem.
Autoregressive models. van den Oord et al. [35] proposed WaveNet, an autoregressive model that
produces high-fidelity speech by directly generating raw waveforms from the input features. WaveNet
is trained by maximizing the likelihood of audio data conditional on the aforementioned linguistic and
pitch features. While WaveNet’s fully convolutional architecture enables efficient training on parallel
hardware, at inference time the model relies on an autoregressive sampling procedure, generating the
waveform one sample at a time. This necessitates tens of thousands of sequential steps for generating
a single second of audio, making it ill-suited for real-time production deployment. These limitations
were partially alleviated by Kalchbrenner et al. [15]. While still autoregressive, using a single-layer
recurrent neural network, weight sparsification and custom kernels, their WaveRNN model achieves
faster-than-realtime on-device synthesis.
Probability density distillation. Parallel WaveNet [36] and ClariNet [27] used a trained autoregressive model such as WaveNet as a teacher network distilling its knowledge into a non-autoregressive
likelihood student model that is trained to minimize the Kullback-Liebler (KL) divergence between
student and teacher. Both approaches rely on an Inverse-Autoregressive Flow (IAF; Kingma et al.
[19]) as a student network. The IAF is structured in such a way that, given a set of latents, the
corresponding observables can be generated efficiently in parallel.
While the methods of Ping et al. [27] and van den Oord et al. [36] differ in the choice of distributions
used in their models, they both found that optimizing the KL-divergence alone was insufficient for
obtaining high-quality generations, and required careful regularization and auxiliary losses for the
student models to converge to a good solution.
Flow-based models. To avoid having to use a two-stage training pipeline required by the distillation
approaches, FloWaveNet [16] and WaveGlow [29] propose directly training a convolutional flow
model based on the architectures of RealNVP [7] and Glow [18] respectively. These models can be
trained using maximum likelihood, and approach the speech quality of WaveNet or its distillations.
However, due to the limited flexibility of their coupling layers (the building blocks used to construct
invertible models) flow-based approaches tend to require large networks. Indeed, both WaveGlow
and FloWaveNet have ≈ 100 convolutional layers, and are slow to train [37].
Concurrently to our work Ping et al. [28] have made great progress towards reducing the size of
flow-based TTS models. Their WaveFlow model achieves high quality speech synthesis using 128
sequential steps (more than two orders of magnitude fewer than a fully autoregressive model) while
maintaining a small parameter footprint.
Implicit generative models. To date, Generative Adversarial Networks (GANs; Goodfellow et al.
[11]) are mostly applied to image generation, where they are known to produce crisp, high-quality
2
images using fully convolutional architectures and relatively small models [5]. Their application to
speech synthesis may provide an alternative to probability distillation that has the potential to match
it in terms of speech quality. Three recent approaches, MelGAN [22], GAN-TTS [3] and Parallel
WaveGAN [38], made significant progress in this direction. While still not matching WaveNet or
ClariNet in speech quality, these works have proven the feasibility of solving TTS with implicit
generative models. However, due to the reliance on adversarial learning, GANs can still be difficult
to train. MelGAN and GAN-TTS rely on carefully chosen regularization and an ensemble of
discriminators to achieve stable training, and MelGAN and Parallel WaveGAN use various auxiliary
losses. This training difficulty also limits the available model choice, as only certain types of models
(e.g. with batch normalization and spectral normalization) are known to be trainable.
3 Maximum Mean Discrepancy and Energy Distance
Before we present our proposed training method in Section 4, we briefly review previous work on
learning implicit generative models, and we introduce the primitives on which our method is built.
Although GANs have recently become the dominant method for training implicit generative models
without tractable likelihood, another popular approach to learning these types of models is a class of
methods based on minimizing Maximum Mean Discrepancy (MMD), defined as
DMMD(p|q) = sup
f∈H

Ex∼p(x)
[f(x)] − Ey∼q(y)
[f(y)]
, (1)
where f is a critic function which is constrained to a family of functions H [see 12], and p(x) and
q(y) are the data and model distributions respectively. When H is given by a family of neural network
discriminators, MMD becomes very similar to GANs, as explained by [2]. The main difference is
that for MMD the maximization over f ∈ H is assumed to be analytically tractable, while GANs
maximize over f approximately by taking a few steps of stochastic gradient descent. The benefit of
exact optimization is that MMD methods are provably stable and consistent, unlike GANs, although
this comes at the cost of more restrictive critic families H.
Gretton et al. [12] show that exact optimization is indeed possible if H is chosen to be a reproducing
kernel Hilbert space (RKHS). In that case, there exists a kernel function k ∈ H such that every critic
f ∈ H can be expressed through its inner product with that kernel:
f(x) = hf, k(·, x)iH =
X
i
αik(x, xi). (2)
In other words, f is constrained to be a weighted sum of basis functions k(x, xi), with weights α.
Exact optimization over α then gives the following expression for the squared MMD:
D2
MMD(p|q) = E[k(x, x
0
) + k(y, y
0
) − 2k(x, y)], (3)
where x, x
0 ∼ p(x) and y, y
0 ∼ q(y) are independent samples from p and q.
Since (3) only depends on expectations over q and p it can be approximated without bias using Monte
Carlo sampling. If our dataset contains N samples from p(x) and we draw M samples from our
model q(y), this gives us the following stochastic loss function [12]:
L(q) = 1
N(N − 1)
X
n6=n0
k(xn, xn0 ) + 1
M(M − 1)
X
m6=m0
k(ym, ym0 ) −
2
MN
X
N
n=1
X
M
m=1
k(xn, ym).
(4)
Loss functions of this type were used by [8, 23] and [4] to train generative models without requiring
a tractable likelihood function.
An alternative view on MMD methods is in terms of distances. As explained by Sejdinovic et al. [32],
the kernel k(·, ·) of a RKHS H induces a distance metric d(·, ·) via
d(x, y) = 1
2
(k(x, x) + k(y, y) − 2k(x, y)). (5)
Assuming that k(x, x) = k(y, y) = c with c being a constant, equation (3) can equivalently be
expressed in terms of this distance:
D2
MMD(p|q) = D2
GED(p|q) = E[2d(x, y) − d(x, x
0
) − d(y, y
0
)], (6)
3
which is known as the generalized energy distance [GED; see e.g. 32, 33, 30].
In most practical applications of generative modeling, such as speech synthesis, we are interested in
learning conditional distributions q(x | c) using examples xi
, ci from the data distribution p. In such
cases we usually only have access to a single example xi for each unique conditioning variable ci
.
This means that we cannot evaluate the term E[d(x, x
0
)] in (6). However, this term only depends on
the data distribution p and not on our generative model q, so it can be dropped during training. The
training loss then becomes
LGED(q) = E[2d(x, y) − d(y, y
0
)], (7)
with y, y
0 ∼ q(·| c) independent samples from our model, conditioned on the same features c. This
type of loss was studied by Gneiting and Raftery [10] under the name energy score. They find that
(7) is a proper scoring rule, i.e. it can lead to a statistically consistent learning method, if the distance
metric d(·, ·) is negative definite. This result is more general than the consistency results for MMD,
and also allows for the use of distances that do not correspond to reproducing kernel Hilbert spaces.
We make use of this result for deriving our proposed learning method, which we present in Section 4.
4 A generalized energy distance based on spectrograms
We require a method to learn generative models that can sample speech in a small number of parallel
steps, without needing access to a tractable likelihood function. The method we propose here achieves
this by computing a generalized energy distance, or energy score, between simulated and real data,
and minimizing this loss with respect to the parameters of our generative model. Here, we assume
that our dataset consist of N examples of speech xi
, labeled by textual or linguistic features ci
. Our
generative model is then a deep neural network that takes a set of Gaussian noise variables zi
, and
maps those to the audio domain as yi = fθ(ci
, zi), with θ the parameters of the neural network. This
implicitly defines a distribution qθ(y | c) of audio y conditional on features c.
Given a minibatch of M examples {xi
, ci}M
i=1, we use our model to generate two independent samples
yi = fθ(ci
, zi), y
0
i = fθ(ci
, z
0
i
) corresponding to each input feature ci
, using two independently
sampled sets of noise variables zi
, z
0
i
. We then calculate the resulting minibatch loss as
L
∗
GED(q) = X
M
i=1
2d(xi
, yi
) − d(yi
, y
0
i
), (8)
where d(·, ·) is a distance metric between samples. The minibatch loss L
∗
GED(q) is an unbiased
estimator of the energy score (7), and minimizing it will thus minimize the generalized energy
distance between our model and the distribution of training data, as discussed in Section 3.
In practice the performance of the energy score strongly depends on the choice of metric d(·, ·).
When generating high-dimensional data, it is usually impossible to model all aspects of the data
with high fidelity, while still keeping the model qθ(y |c) small enough for practical use. We thus
have to select a distance function that emphasizes those features of the generated audio that are most
important to the human ear. This is similar to how GANs impose a powerful visual inductive bias
when modeling images using convolutional neural network discriminators. Following the literature
on speech recognition [20, 1], we thus define our distance function over spectrograms s
k
(xi), where
a spectrogram is defined as the magnitude component of the short-time Fourier transform (STFT) of
an input waveform, |STFTk(xi)|, where k is the frame-length used in the STFT. Following Engel
et al. [9] we combine multiple such frame-lengths k into a single multi-scale spectrogram loss. Our
distance function to be used in the generalized energy distance then becomes
d(xi
, xj ) = X
k∈[26,...,2
11]
X
t
|| s
k
t
(xi) − s
k
t
(xj )||1 + αk|| log s
k
t
(xi) − log s
k
t
(xj )||2, (9)
where we sum over a geometrically-spaced sequence of window-lengths between 64 and 2048, and
where s
k
t
(xi) denotes the t-th timeslice of the spectrogram of xi with window-length k. The weights
αk of the L2 components of the distance are discussed in Appendix A. As we show there, the analysis
of Gneiting and Raftery [10, Theorem 5.1] can be used to show that this choice makes (8) a strictly
proper scoring rule for learning qθ(x | c) with respect to the ground-truth conditional distribution over
spectrograms, meaning that LGED(q) > LGED(p) for any q(s
k
(x)| c) 6= p(s
k
(x)| c). Minimizing this
easily computable loss, we thus obtain a stable and statistically consistent learning method.
4
4.1 Why we need the repulsive term
Spectrogram-based losses are popular in the literature on audio generation. For example, the
probability distillation methods ClariNet [27] and Parallel WaveNet [36] minimize the distance
between spectrogram magnitudes of real and synthesized speech in addition to their main distillation
loss; and Pandey and Wang [26] use a spectrogram-based loss for speech enhancement. Multiresolution spectrogram losses like ours were used previously by Wang et al. [37] and Yamamoto et al.
[38] for speech synthesis, and by Engel et al. [9] and Dhariwal et al. [6] for music generation. The
main difference between these approaches and our generalized energy distance (Equation 9) is the
presence of a repulsive term between generated data in our training loss, −d(yi
, y
0
i
), in addition to
the attractive term between generated data and real data, d(xi
, yi
).
The presence of the repulsive term is necessary for our loss to be a proper scoring rule for learning the
conditional distribution of audio given linguistic features. Without this term, generated samples will
collapse to a single point without trying to capture the full distribution. For many purposes like speech
and music synthesis it might be argued that a single conditional sample is all that is needed, as long as
it is a good sample. Unfortunately the standard loss without the repulsive term also fails at this goal,
as shown in Figure 1. If the conditional distribution of training data is multi-modal, regression losses
without repulsive term can produce samples that lie far away from any individual mode (Figure 1a).
Even if the conditional distribution of training data is unimodal, such losses will tend to produce
samples that are atypical of training data when applied in high dimensions (Figure 1b).
10 5 0 5 10
x1
0
5
10
15
20
x
2
(a) Samples from a two-dimensional Gaussian mixture
model with three components.
0.0 0.2 0.4 0.6 0.8 1.0 1.2
Sample norm
0.3
0.2
0.1
0.0
0.1
0.2
0.3
Sample mean
Training data
Energy distance
No repulsive term
(b) Samples x from a single 100-dim Gaussian, with
||x||2 on the x-axis and Pn
i xi/n on the y-axis.
Figure 1: Samples from models trained by minimizing the energy distance (blue) or the more
commonly used loss without repulsive term (green), and comparing to samples from the training data
(red). Samples from the energy distance trained model are representative of the data, and all sampled
points lie close to training examples. Samples from the model trained without repulsive term are not
typical of training data. A notebook to reproduce these plots is included in our github repository.
In Section 7 we perform ablation experiments to further examine the role of the repulsive term for
our specific application of speech synthesis. There, we show that this term is critical for achieving
optimal performance in practice.
5 Model and training procedure
The models we train using the loss function we derived in Section 4 consist of deep neural networks
that map noise variables to the audio domain, conditioned on linguistic features, that is yi = fθ(ci
, zi).
This is similar to how conditional generator networks are usually parameterized in GANs, see
e.g. BigGAN [5] for the analogous case where images y are generated from noise z and class labels
c. For the generator network fθ we explore 2 different choices:
Simplified GAN-TTS generator To clearly demonstrate the effect that using the generalized
energy distance has on model training, we attempt to control for other sources of variation by
using a generator architecture nearly identical to that of GAN-TTS [3]. Specifically, we use a
deep 1D convolutional residual network [13] consisting of 7 residual blocks (see Figure 3 of the
5
Appendix). Compared to the generator of GAN-TTS, we simplify the model by removing the Spectral
Normalization [25] and output Batch Normalization [34], which we empirically find to be either
unnecessary or hurting model performance.
Inverse STFT architecture To experiment with the wider choice in generative models allowed
by our training method, we additionally explore a model that makes use of the Short Time Fourier
Transform (STFT) representation that is prevalent in audio processing, and which we also used to
define the energy distance we use for training. This model takes in the features and noise variables,
and produces an intermediate representation stfti = fθ(ci
, zi) which we interpret as representing a
STFT of the waveform yi
that is to be generated. Here, fθ consists of a stack of standard ResNet
blocks that is applied without any upsampling, and is therefore faster to run than our simplified
GAN-TTS generator. We then linearly project stfti
to the waveform space by applying an inverse
STFT transformation, thereby upsampling 120× in one step. The final output of this model is thus a
raw waveform, similar to the (simplified) GAN-TTS model. Further details on this architecture are
given in Appendix D.4.
c
z
z'
x
Input Waveform Spectrogram Loss
repulsive
attractive
y
y'
Figure 2: Visual depiction of our training process.
Training procedure All of our models
are trained on Cloud TPUs v3 with hyperparameters as described in Table 5 of the
Appendix. For each training example we
generate two independent batches of audio samples from our model, conditioned
on the same features, which are then used
to compute our training loss. Our model
parameters are updated using Adam [17].
Figure 2 explains this training procedure
visually.
6 Data
Our TTS models are trained on a single-speaker North American English dataset, consisting of speech
data spoken by a professional voice actor. The data consists of approximately sixty thousand utterances with durations ranging approximately from 0.5 seconds to 1 minute, and their corresponding
aligned linguistic features and pitch information. Linguistic features encode phonetic and duration
information, while the pitch is given by the logarithmic fundamental frequency log F0. These features, a total of 567, are used by our models as inputs and provide local conditioning information
for generating the raw waveform. At training time, the features are derived from and aligned with
the training audio. At test time, all features are predicted by a separate model; we thus never use
ground-truth information extracted from human speech when evaluating our models.
To account for differences in utterance duration, during training we sample training examples with
probability proportional to their length, and then uniformly sample 2 second windows and their
corresponding features from these utterances. Examples shorter than 2 seconds are filtered out,
leaving a total of 44.6 hours of speech sampled at 24 kHz. The corresponding conditioning features
are provided at 5ms intervals (200 Hz sampling frequency). The trained models are thus tasked with
converting linguistic and pitch features into raw audio, while upsampling by a factor of 120. Our
training setup is similar to that of Binkowski et al. ´ [3], except that we do not apply any transformations
(e.g. a µ-transform) to the waveforms.
7 Experiments
We evaluate our proposed approach to speech synthesis by training 4 different models on the data set
described in the previous section:
1. The simplified GAN-TTS generator described in Section 5, but trained by minimizing our
generalized energy distance.
2. This same model and loss, but leaving out the repulsive term −d(yi
, y
0
i
) as in previous
works that use spectrogram-based losses.
6
3. Our inverse STFT model from Section 5 trained with the GED loss.
4. A hybrid architecture where we combine the GED loss with adversarial training using an
ensemble of unconditional discriminators. Previous works like GAN-TTS and MelGAN
use an ensemble of GAN discriminators with conditional discriminators taking in features c,
and unconditional discriminators that look only at the generated data y. We hypothesize
that our GED loss is a good substitute for the conditional part of the GAN loss, but that
using an unconditional discriminator might yet offer additional benefit.
To evaluate our generated speech, we report the (conditional) Fréchet Deep Speech Distances (FDSD
and cFDSD; Binkowski et al. ´ [3]) - metrics that judge the quality of synthesized audio samples based
on their distance to a reference set. These distances are conceptually similar to the FID (Fréchet
Inception Distance; Heusel et al. [14]) commonly used for evaluating GANs of natural images, but
differ in that they (i) are computed on the activations of the Deep Speech 2 [1] speech recognition
model in place of the activations of the Inception network [34] used in FID; and (ii) are computed for
samples with conditioning features that match the reference set in the case of the conditional FDSD
(cFDSD). We closely followed Binkowski et al. ´ [3] in our implementation of the FDSD metrics,
but note several differences between the two implementations in Appendix E.1. We report these
metrics on both the training data as well as a larger validation set. In addition, we also evaluate
the quality of the synthesized audio using the Mean Opinion Score (MOS) computed from ratings
assigned by trained human evaluators. These samples are generated on an independent set of 1000
out-of-distribution sentences for which no ground-truth data is available.
We compare our models against a careful re-implementation of GAN-TTS [3], built with help from
the authors. Results are reported in Table 1 and include links to samples from each of our models.
Table 1: Mean Opinion Score (MOS) and (conditional) Fréchet Deep Speech Distances [3] (FDSD
and cFDSD respectively) for prior work and the proposed approach. Models trained by minimizing
our spectral generalized energy distance are indicated with GED. Our proposed generator using
inverse STFT upsampling is marked iSTFT. For FDSD and cFDSD we report training scores for
comparison to the numbers in Binkowski et al. ´ [3], as well as scores on the validation set. We
truncate the sampling distribution of latents when generating from our models, as previously done in
BigGAN [5]; we find this to give a slight boost in performance.
TRAIN TRAIN VALID VALID AUDIO
MODEL MOS FDSD CFDSD FDSD CFDSD SAMPLES
Natural speech 4.41 ± 0.06 0.143 0.156
Autoregressive models
WAVENET [15] 4.51† ± 0.08
WAVERNN [15] 4.48† ± 0.07
Parallel models
MELGAN [22] 3.72†
PARALLEL WAVEGAN [38] 4.06†
GAN-TTS [3] 4.21† ± 0.05 0.184 0.060
Our models
GAN-TTS re-implementation 4.16 ± 0.06 0.163 0.053 0.193 0.077 [Link]
GED same generator 4.03 ± 0.06 0.151 0.020 0.164 0.038 [Link]
GED no repulsive term 3.00 ± 0.07 0.145 0.023 0.171 0.048 [Link]
GED + iSTFT generator 4.10 ± 0.06 0.138 0.020 0.164 0.037 [Link]
GED + unconditional GAN 4.25 ± 0.06 0.147 0.030 0.169 0.040 [Link]
† Mean Opinion Scores reported by other works are included for reference, but may not be directly comparable
due to differences in the data, in the composition of human evaluators, or in the evaluation instructions.
7.1 Discussion
Spectral energy distance for TTS We studied the effect that switching from adversarial training
to training with the spectral energy distance has on the resulting models. To minimize the sources
7
of variation we used a generator architecture similar to that of the GAN-TTS (see Section 5 and
Appendix 4). Table 1 shows that in terms of the cFDSD scores models trained with the GED loss
improve by ≈ 2× on the previously published adversarial model, GAN-TTS, suggesting that they
are better at capturing the underlying conditional waveform distributions. We verified that this
improvement is not due to overfitting by re-training the models on a smaller dataset (38.6 hours) and
re-computing these metrics on a larger validation set (5.8 hours). We note, however, that the improved
cFDSD scores did not transfer to higher subjective speech quality. In fact GED-only samples achieve
lower MOS than the adversarial baseline, and empirically we found that FDSD metrics are most
informative when comparing different versions of the same architecture and training setup, but not
across different models or training procedures.
In two ablation studies (see Appendix B and C) of the components of our spectral energy loss we
confirmed that the GED’s repulsive term and the use of multiple scales in the spectral distance
function are important for model performance. Moreover, a comparison between the results for
GED and GED no repulsive term in Table 1 shows a significant decrease in MOS scores when the
repulsive term is not present; and qualitatively, in the absence of the repulsive term, the generated
speech sounds metallic. Since using spectrogram-based losses without the repulsive term is standard
practice, we feel that comparison against this baseline is most informative in forecasting how useful
the proposed techniques will be for the wider community.
Combining GED and adversarial training The GED loss provides a strong signal for learning
the conditional (local) waveform distribution given the linguistic features, but unlike GANs it does not
explicitly emphasize accurately capturing the marginal distribution of speech. Empirically, we find
that our GED-trained models can sometimes generate audio that, while perfectly audible and closely
matching the original speech in timing and intonation, might still sound somewhat robotic. This
suggests that these models might still benefit from the addition of an adversarial loss that specifically
emphasizes matching the marginal distribution of speech. To test this, we trained the GAN-TTS
architecture with its conditional discriminators replaced by a single GED loss. The resulting model
(GED + unconditional GAN in Table 1) improves on the GED-only model as well as on GAN-TTS,
achieving the best-in-class MOS of 4.25 ± 0.06.
Choice of network architectures Encouraged by the stable training of our models with GED, we
explored alternative architectures for speech synthesis, like our iSTFT generator (see Section 5 and
Appendix D.4) that generates the coefficients of a Fourier basis and uses them within the inverse
STFT transform to produce the final waveform. We find (GED + iSTFT generator in Table 1) that
this architecture achieves the best training and validation (c)FDSD scores of the models we tried.
In addition, it trains the fastest of our models, reaching optimal cFDSD in as little as 10 thousand
parameter updates, with the per-update running time being about half that of the GAN-TTS generator.
Unfortunately, this model did not significantly improve upon our results with the simplified GAN-TTS
generator in terms of MOS. We tried using the iSTFT architecture in combination with adversarial
learning but did not manage to get it to train in a stable way. This supports our belief that the spectral
energy distance proposed in this work has the potential to enable the use of a much wider class of
network architectures in generative modeling applications, and the design of novel architectures
meeting the needs of specific applications (e.g. on-device efficiency).
Train/test performance and overfitting Our models trained on the generalized energy distance
are able to very quickly obtain good cFDSD scores after just 10 to 20 thousand parameter updates.
When trained longer without any regularization, validation performance starts to deteriorate after that
point. Unregularized, our models are able to produce samples on the training set that are very hard to
distinguish from the data. We are actively working on developing new regularization techniques that
more effectively translate this capacity into test set performance as measured by MOS.
8 Conclusion
We proposed a new generalized energy distance for training generative models of speech without
requiring a closed form expression for the data likelihood. Our spectral energy distance is a proper
scoring rule with respect to the distribution over spectrograms of the generated waveform audio.
The distance can be calculated from minibatches without bias, and does not require adversarial
learning, yielding a stable and consistent method for training implicit generative models. Empirical
8
results show that our proposed method is competitive with the state of the art in this model class, and
improves on it when combined with adversarial learning.
Our proposed spectral energy distance is closely related to other recent work in audio synthesis [37,
38, 9, 6], in that it is based on calculating distances between spectrograms, but we believe it is the
first to include a repulsive term between generated samples, and thus the first proper scoring rule of
this type. We empirically verified that this is important for obtaining optimal generation quality in our
case. Applying our scoring rule to the applications of these other works may offer similar benefits.
With the model and learning method we propose here, we take a step towards closing the performance
gap between autoregressive and parallel generative models of speech. With further modeling effort
and careful implementation, we hope that our method will be used to enable faster and higher quality
generation of audio in live text-to-speech as well as other practical applications.
Broader impact
The primary contributions of this paper introduce methodological innovations that improve the
automated generation of speech audio from text. Positive aspects of automated text to speech could
include improved accessibility for blind and elderly people or others who have poor eyesight. TTS is
a cornerstone of assistive technology and e.g. is already used in the classroom to aid children with
developmental disorders with reading comprehension. Although it is not within the scope of this
work, automated TTS could be re-purposed to mimic a specific individual towards benevolent goals
(e.g. to comfort someone with the voice of a loved one) or nefarious goals (e.g. to fake someone’s
voice without their permission).
Funding disclosure
This work was funded by Google. None of the authors had financial relationships with other entities
relevant to this work.
Acknowledgments
We would like to thank Heiga Zen, Norman Casagrande and Sander Dieleman for their insightful
comments, help with get acquainted with speech synthesis research and best practices, and for their
aid with reproducing GAN-TTS results.
References
[1] Dario Amodei, Sundaram Ananthanarayanan, Rishita Anubhai, Jingliang Bai, Eric Battenberg,
Carl Case, Jared Casper, Bryan Catanzaro, Qiang Cheng, Guoliang Chen, et al. Deep Speech
2: End-to-end speech recognition in English and Mandarin. In International conference on
machine learning, pages 173–182, 2016.
[2] Martin Arjovsky, Soumith Chintala, and Léon Bottou. Wasserstein gan. arXiv preprint
arXiv:1701.07875, 2017.
[3] Mikołaj Binkowski, Jeff Donahue, Sander Dieleman, Aidan Clark, Erich Elsen, Norman ´
Casagrande, Luis C Cobo, and Karen Simonyan. High fidelity speech synthesis with adversarial
networks. arXiv preprint arXiv:1909.11646, 2019.
[4] Diane Bouchacourt, Pawan K Mudigonda, and Sebastian Nowozin. Disco nets: Dissimilarity
coefficients networks. In Advances in Neural Information Processing Systems, pages 352–360,
2016.
[5] Andrew Brock, Jeff Donahue, and Karen Simonyan. Large scale GAN training for high fidelity
natural image synthesis. arXiv preprint arXiv:1809.11096, 2018.
[6] Prafulla Dhariwal, Heewoo Jun, Christine Payne, Jong Wook Kim, Alec Radford, and Ilya
Sutskever. Jukebox: A generative model for music. https://cdn.openai.com/papers/jukebox.pdf,
2020.
9
[7] Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using Real NVP.
arXiv preprint arXiv:1605.08803, 2016.
[8] Gintare Karolina Dziugaite, Daniel M Roy, and Zoubin Ghahramani. Training generative neural
networks via maximum mean discrepancy optimization. arXiv preprint arXiv:1505.03906,
2015.
[9] Jesse Engel, Lamtharn Hantrakul, Chenjie Gu, and Adam Roberts. DDSP: Differentiable Digital
Signal Processing. arXiv preprint arXiv:2001.04643, 2020.
[10] Tilmann Gneiting and Adrian E Raftery. Strictly proper scoring rules, prediction, and estimation.
Journal of the American statistical Association, 102(477):359–378, 2007.
[11] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil
Ozair, Aaron Courville, and Yoshua Bengio. Generative Adversarial Nets. In Advances in
neural information processing systems, pages 2672–2680, 2014.
[12] Arthur Gretton, Karsten M Borgwardt, Malte J Rasch, Bernhard Schölkopf, and Alexander
Smola. A kernel two-sample test. Journal of Machine Learning Research, 13(Mar):723–773,
2012.
[13] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image
recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition,
pages 770–778, 2016.
[14] Martin Heusel, Hubert Ramsauer, Thomas Unterthiner, Bernhard Nessler, and Sepp Hochreiter.
GANs trained by a two time-scale update rule converge to a local Nash equilibrium. In Advances
in neural information processing systems, pages 6626–6637, 2017.
[15] Nal Kalchbrenner, Erich Elsen, Karen Simonyan, Seb Noury, Norman Casagrande, Edward
Lockhart, Florian Stimberg, Aaron van den Oord, Sander Dieleman, and Koray Kavukcuoglu.
Efficient neural audio synthesis. arXiv preprint arXiv:1802.08435, 2018.
[16] Sungwon Kim, Sang-gil Lee, Jongyoon Song, Jaehyeon Kim, and Sungroh Yoon. FloWaveNet:
A generative flow for raw audio. arXiv preprint arXiv:1811.02155, 2018.
[17] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
[18] Durk P Kingma and Prafulla Dhariwal. Glow: Generative flow with invertible 1x1 convolutions.
In Advances in Neural Information Processing Systems, pages 10215–10224, 2018.
[19] Durk P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling.
Improved variational inference with Inverse Autoregressive Flow. In Advances in neural
information processing systems, pages 4743–4751, 2016.
[20] Brian ED Kingsbury, Nelson Morgan, and Steven Greenberg. Robust speech recognition using
the modulation spectrogram. Speech communication, 25(1-3):117–132, 1998.
[21] Oleksii Kuchaiev, Boris Ginsburg, Igor Gitman, Vitaly Lavrukhin, Carl Case, and Paulius
Micikevicius. OpenSeq2Seq: extensible toolkit for distributed and mixed precision training of
sequence-to-sequence models. In Proceedings of Workshop for NLP Open Source Software
(NLP-OSS), pages 41–46, 2018.
[22] Kundan Kumar, Rithesh Kumar, Thibault de Boissiere, Lucas Gestin, Wei Zhen Teoh, Jose
Sotelo, Alexandre de Brébisson, Yoshua Bengio, and Aaron C Courville. MelGAN: Generative
adversarial networks for conditional waveform synthesis. In Advances in Neural Information
Processing Systems, pages 14881–14892, 2019.
[23] Yujia Li, Kevin Swersky, and Rich Zemel. Generative moment matching networks. In International Conference on Machine Learning, pages 1718–1727, 2015.
[24] Jae Hyun Lim and Jong Chul Ye. Geometric GAN. arXiv preprint arXiv:1705.02894, 2017.
10
[25] Takeru Miyato, Toshiki Kataoka, Masanori Koyama, and Yuichi Yoshida. Spectral normalization
for generative adversarial networks. arXiv preprint arXiv:1802.05957, 2018.
[26] Ashutosh Pandey and DeLiang Wang. A new framework for CNN-based speech enhancement
in the time domain. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 27
(7):1179–1188, 2019.
[27] Wei Ping, Kainan Peng, and Jitong Chen. ClariNet: Parallel wave generation in end-to-end
Text-to-Speech. arXiv preprint arXiv:1807.07281, 2018.
[28] Wei Ping, Kainan Peng, Kexin Zhao, and Zhao Song. WaveFlow: A compact flow-based model
for raw audio. arXiv preprint arXiv:1912.01219, 2019.
[29] Ryan Prenger, Rafael Valle, and Bryan Catanzaro. WaveGlow: A flow-based generative network
for speech synthesis. In ICASSP 2019-2019 IEEE International Conference on Acoustics,
Speech and Signal Processing (ICASSP), pages 3617–3621. IEEE, 2019.
[30] Tim Salimans, Dimitris Metaxas, Han Zhang, and Alec Radford. Improving GANs using
optimal transport. In 6th International Conference on Learning Representations, ICLR 2018,
2018.
[31] Andrew M Saxe, James L McClelland, and Surya Ganguli. Exact solutions to the nonlinear
dynamics of learning in deep linear neural networks. arXiv preprint arXiv:1312.6120, 2013.
[32] Dino Sejdinovic, Bharath Sriperumbudur, Arthur Gretton, and Kenji Fukumizu. Equivalence of
distance-based and RKHS-based statistics in hypothesis testing. The Annals of Statistics, pages
2263–2291, 2013.
[33] Cencheng Shen and Joshua T Vogelstein. The exact equivalence of distance and kernel methods
for hypothesis testing. arXiv preprint arXiv:1806.05514, 2018.
[34] Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jon Shlens, and Zbigniew Wojna. Rethinking the Inception architecture for computer vision. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 2818–2826, 2016.
[35] Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex
Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. WaveNet: A generative
model for raw audio. arXiv preprint arXiv:1609.03499, 2016.
[36] Aaron van den Oord, Yazhe Li, Igor Babuschkin, Karen Simonyan, Oriol Vinyals, Koray
Kavukcuoglu, George van den Driessche, Edward Lockhart, Luis C Cobo, Florian Stimberg,
et al. Parallel WaveNet: Fast high-fidelity speech synthesis. arXiv preprint arXiv:1711.10433,
2017.
[37] Xin Wang, Shinji Takaki, and Junichi Yamagishi. Neural source-filter-based waveform model for
statistical parametric speech synthesis. In ICASSP 2019-2019 IEEE International Conference
on Acoustics, Speech and Signal Processing (ICASSP), pages 5916–5920. IEEE, 2019.
[38] Ryuichi Yamamoto, Eunwoo Song, and Jae-Min Kim. Parallel WaveGAN: A fast waveform generation model based on generative adversarial networks with multi-resolution spectrogram. In
ICASSP 2020-2020 IEEE International Conference on Acoustics, Speech and Signal Processing
(ICASSP), pages 6199–6203. IEEE, 2020.
[39] Heiga Zen, Keiichi Tokuda, and Alan W Black. Statistical parametric speech synthesis. Speech
communication, 51(11):1039–1064, 2009.
11
Appendix A A proper scoring rule for speech synthesis
A loss function or scoring rule L(q, x) measures how well a model distribution q fits data x drawn
from a distribution p. Such a scoring rule is called proper if its expectation is minimized when q = p.
If the minimum is also unique, the scoring rule is called strictly proper. In the large data limit, a
strictly proper scoring rule can uniquely identify the distribution p, which means that it can be used
as the basis of a statistically consistent learning method.
In Section 4 we propose learning implicit generative models of speech by minimizing the generalized
energy score [10] given by
LGED(q, xi) = Eyi
,y
0
i∼q 2d(xi
, yi
) − d(yi
, y
0
i
), (10)
where d is a distance function over training examples xi and generated samples yi
, y
0
i
, both of which
can be conditioned on a set of features ci
.
In choosing d(), we follow the analysis of Gneiting and Raftery [10, Theorem 5.1, Example 5.7],
who study the family of distance functions of the form d(xi
, xj ) = || xi − xj ||β
α and prove that this
choice makes (10) a proper scoring rule for learning p(x) if α ∈ (0, 2] and β ∈ (0, α]. This includes
the special cases of L1 and L2 distance, the latter of which they show leads to a strictly proper scoring
rule.
Given the restrictions set out by this analysis, and building on the domain-specific work of Engel
et al. [9], we arrived at the following multi-scale spectrogram loss as our choice for d:
d(xi
, xj ) = X
k∈[26,...,2
11]
X
t
|| s
k
t
(xi) − s
k
t
(xj )||1 + αk|| log s
k
t
(xi) − log s
k
t
(xj )||2, (11)
where we sum over a geometrically-spaced sequence of STFT window-lengths between 64 and 2048,
and where s
k
t
(xi) denotes the t-th timeslice of the spectrogram of xi with window-length k.
Rather than having a single scoring rule (10) combined with a multi-scale distance d(), we can
equivalently rewrite our loss function as a sum over multiple scoring rules, each having a more simple
distance function:
LGED(q, xi) = X
k∈[26,...,2
11]
X
t
L
k,t
1
(q, xi) + αkL
k,t
2
(q, xi) (12)
L
k,t
1
(q, xi) = Eyi
,y
0
i∼q 2|| s
k
t
(xi) − s
k
t
(yi
)||1 − || s
k
t
(yi
) − s
k
t
(y
0
i
)||1
L
k,t
2
(q, xi) = Eyi
,y
0
i∼q 2|| log s
k
t
(xi) − log s
k
t
(yi
)||2 − || log s
k
t
(yi
) − log s
k
t
(y
0
i
)||2.
Here, each of the individual L
k,t
1
(q, xi) and L
k,t
2
(q, xi) terms is a proper scoring rule since it uses a
L1 or L2 distance with respect to (the log of) the spectrogram slice s
k
t
(xi). Furthermore, the sum of
multiple proper scoring rules is itself a proper scoring rule, and it is strictly proper as long as at least
one of the elements in the sum is strictly proper. This means that our combined loss LGED(q, xi) is
indeed a strictly proper scoring rule with respect to p(s
k
t
). It follows that it is also a proper scoring
rule for p(x | c), but not necessarily a strictly proper one, since x may have long-range dependencies
that cannot be identified from single spectrogram slices s
k
t
. We also experimented with adding such
longer range terms to our training loss but found no additional empirical benefit.
We experimented with various weights αk for the L2 term in (11), and found αk =
p
k/2 to work
well. This choice approximately equalizes the influence of all the different L1 and L2 terms on the
gradient with respect to our generator parameters θ. Dropping the L2 terms by setting αk = 0 only
gave us slightly worse results, and could be used as a simpler alternative.
For the calculation of the spectrograms s
k
(xi) we obtained slightly better sounding results when
mapping raw STFT outputs to the mel-frequency-scale, but with slightly worse results in terms of
cFDSD. All reported results are with mel-scale spectrograms.
Appendix B Ablation study on the spectral energy distance
We carried out an ablation study, in which we systematically varied aspects of the spectral energy
distance proposed in Section 4 while using the architecture described in Section 5. The results of
12
these ablations are presented in Table 2. We note that at a high level we observe that any deviation
from the proposed spectral energy distance leads to higher (worse) values of the validation (c)FDSD
metrics, and discuss specific ablation experiments below.
Compared to the Baseline GED model, the same model without the repulsive term (“Generalised
energy distance: disabled” in Table 2) not only gets worse FDSD scores, but also significantly reduces
quality of the synthesized speech (see Section 7), suggesting that this part of the loss is crucial for the
models ability to accurately capture the underlying conditional waveform distributions.
We compute spectrograms using an overcomplete basis of sinusoids. An exploration of the effect of
this oversampling (“DCT / DST overcompleteness” in Table 2) shows that the FDSD metric values
stops improving beyond the use of an 8× overcomplete basis. Another benefit of an overcomplete
basis that is not captured by Table 2 is faster convergence of models with a more overcomplete basis;
but this improvement too tapered off once the basis was at least 8× overcomplete.
Finally, we explored the importance of using a multiple spectrogram scales in the GED loss (“Window
sizes” in Table 2) by training models that each used only a single window size k for its spectrograms.
Our results show that individually all of the constituent window sizes yield worse results than when
they are combined in a single loss, suggesting that use of multiple spectrogram scales is an important
aspect of the proposed spectral energy distance.
Table 2: Validation FDSD metric values for experiments comparing the proposed model and its
variants. The ablation experiments only ran for 200 × 103
training steps and not until convergence.
VALID VALID
STUDY VARIANT FDSD CFDSD
Baseline GED 0.163 0.040
Generalized energy distance disabled 0.170 0.047
DCT / DST overcompleteness 1x 0.165 0.042
2x 0.165 0.041
4x 0.168 0.041
16x 0.163 0.041
Window sizes 64 0.195 0.087
128 0.168 0.046
256 0.166 0.043
512 0.174 0.048
1024 0.182 0.064
2048 0.202 0.093
Appendix C Ablation study combining GED and GANs
On the suggestion of the reviewers we performed an additional ablation study to more carefully
examine the interaction of an adversarial loss with our proposed GED loss. Table 3 shows cFDSD
and MOS results for all combinations of 1) using a repulsive term or not, 2) using a multi-scale or
single-scale spectrogram loss, and 3) using an unconditional GAN loss or not. These experiments
ran for the full 106
training steps, and include MOS scores as well as cFDSD scores, making them
complimentary to the ablation study shown in Table 2.
The results in Table 3 confirm that including the repulsive term in the spectral energy distance always
improves over the naive spectrogram loss in terms of MOS. Furthermore, we find that adding the
adversarial loss is generally helpful, and that the multi-scale loss outperforms the single-scale loss.
Finally, we also ran an experiment combining our GED loss with GAN-TTS, with the conditional
discriminators of GAN-TTS included. This experiment can be compared against the results in the
main paper that only include unconditional discriminators when combining GED and GAN. As
Table 4 shows, the combination of full GAN-TTS and GED performs about equally well as our
proposed combination of GED and unconditional GAN. Both outperform the baseline of GAN-TTS
without GED loss.
13
Table 3: Results for all combinations of (1) repulsive term (r) yes/no, (2) multi-scale (m) or single
window size (256/512) or no spectrogram loss, (3) unconditional GAN loss (G) yes/no. Note that
these ablations sampled the cFDSD validation set uniformly, where we used length-weighted sampling
for the main paper and Table 4 below.
model→ r+m+G r+m r+256+G r+512+G r+256 r+512
cFDSD→ 0.033 0.033 0.344 0.063 0.035 0.034
MOS→ 4.25 ± 0.06 4.06 ± 0.06 3.67 ± 0.07 3.96 ± 0.059 3.44 ± 0.07 2.89 ± 0.09
model→ m+G m 256+G 512+G 256 512
cFDSD→ 0.039 0.039 0.200 0.047 0.040 0.038
MOS→ 4.12 ± 0.06 3.00 ± 0.07 2.86 ± 0.07 3.82 ± 0.06 2.33 ± 0.06 2.48 ± 0.06
Table 4: Results for combining our proposed GED loss with full GAN-TTS, including the conditional
discriminators, and comparing against GED + unconditional GAN, and GAN-TTS.
model→ GED + full GAN-TTS GED + uncond. GAN GAN-TTS only
cFDSD→ 0.041 0.040 0.077
MOS→ 4.24 ± 0.05 4.25 ± 0.06 4.16 ± 0.06
Appendix D Training and architecture details
D.1 Spectral distance
In practice, when computing the STFT spectrograms necessary for the spectral GED loss (9), we
found that the training was more stable when spectrograms s
k
i
and s
k
j were computed with Hann
windowing, 50% overlap and using an overcomplete Fourier basis. This is equivalent to transforming
the windows of length k using the Discrete Cosine and Discrete Sine (DCT and DST) with basis
functions cos( 2π
k
·
i
m ) and sin( 2π
k
·
i
m ) to obtain the real and imaginary parts of the STFT, where
m is an integer oversampling multiplier and i = 0, . . . ,
mk
2 + 1. For m = 1 this is equivalent to the
standard Fourier transform, and we used m = 8 in our experiments. Importantly, we observed that
using an ×8 overcomplete basis did not significantly slow down training on modern deep learning
hardware.
D.2 Training details
Unless otherwise specified, all models were trained with the same hyper-parameters (see Table 5) on
Cloud TPUs v3 with 128-way data parallelism and cross-replica Batch Normalization. Furthermore,
unless otherwise specified, no additional regularization was used, i.e. the spectral energy distance was
minimized directly. A single experiment took between 2 and 4 days to complete 106
training steps.
GED + unconditional GAN used GAN-TTS hyper-parameters from Table 6, but with the generator
learning rate set to 1 × 10−4
. The weight of the GED loss was set to 3.
GED + iSTFT generator used the Adamax [17] optimizer with β1 = 0.9, β2 = 0.9999, learning rate
10−3 with a linear warmup over 12000 steps, EMA decay rate of 0.99998 and early stopping to avoid
overfitting.
D.3 Simplified GAN-TTS generator
To convincingly demonstrate the usefulness of the generalized energy distance for learning implicit
generative models of speech, we sought to compare it to GAN-TTS, a state-of-the-art adversarial
TTS model. To this end in our core experiments we used an architecture that is nearly identical to
that of the GAN-TTS generator, but is further simplified as described in Section 5 and as depicted in
Figure 3.
14
Table 5: Default hyper-parameters.
HYPER-PARAMETER VALUE
Optimizer Adam [17]
Adam β1 0.9
Adam β2 0.999
Adam  10−8
Learning rate 3 × 10−4
Learning rate schedule Linear warmup over 6000 steps
Initialization: shortcut convolutions Zeros
Initialization: conditional Batch Normalization Zeros
Initialization: rest Orthogonal [31]
EMA decay rate 0.9999
Batch Normalization  10−4
Batch size 1024
Training steps 106
D.4 Inverse STFT generator
Stem Conv
size: 1, ch: 2048,
bias: True
c
12x ResNet
2048->512->2048
Inverse STFT
Exponential Scaling
y
z
Flower Conv
size: 1, ch: 240
Figure 5: iSTFT model.
Our inverse STFT generator takes in linguistic features c at a frequency
of 1 feature vector per 120 timesteps (a chunk). A 1D convolution with
kernel size 1 is used to project the features to a 2048 dimensional vector
per chunk, which is then fed into a stack of 12 bottleneck ResNet blocks
[13].
Each of the ResNet blocks consists of a kernel size 1 convolution to
512 channels, 2 convolutions of kernel size 5 at 512 channels, followed
by projection to 2048 channels again. In-between the convolutions we
use conditional batch normalization as also used in GAN-TTS and as
described in Section E.
Finally we project down to 240 dimensions per chunk. Of these dimensions, one is used to exponentially scale the remaining 239 features. These
remaining features are then interpreted as the non-redundant elements of
an STFT with window size 240 and frame step 120, and are projected
to the waveform space using a linear inverse STFT transformation. The
model stack is visualized in Figure 5.
Appendix E GAN-TTS baseline
We re-implemented the GAN-TTS model from Binkowski et al. ´ [3] for use as a baseline in our
experiments. While attempting to reproduce the original implementation as closely as possible by
following the description provided in [3], we observed that our implementation of the model (i)
would not match the reported FDSD scores (reaching an cFDSD of ≈ 2.5 instead of the reported
0.06); and (ii) would diverge during training. To alleviate these discrepancies, we found it necessary
to deviate from the architecture and training procedure described in Binkowski et al. ´ [3] in several
ways detailed below. Our modified implementation reaches cFDSD of 0.056 and trains stably.
No µ-transform. We found that the use of a µ-transform with 16-bit encoding (µ = 216 − 1)
was the single largest factor responsible for low-quality samples in our initial implementation of
GAN-TTS. With the µ-transform enabled (i.e. generating and discriminating transformed audio), our
GAN-TTS baseline converged very slowly and would only reach cFDSD of ≈ 2.5 (see Figure 6).
Disabling the µ-transform was necessary for reaching competitive sample quality (0.056 cFDSD and
4.16 MOS). We also observed that the use of µ-transform made training more unstable.
Generator architecture. We re-used most of the original generator architecture described in
Binkowski et al. ´ [3], but empirically found that (i) adding a batch normalization followed by a
15
Stem Conv
size: 3, ch: 768,
bias: True
c
GBlock
ch: 768
GBlock
ch: 768
GBlock
ch: 384, up: 2x
GBlock
ch: 384, up: 2x
GBlock
ch: 384, up: 2x
GBlock
ch: 192, up: 3x
GBlock
ch: 96, up: 5x
Flower Conv
size: 3, ch: 1,
bias: True
tanh
x
z
(a) Generator architecture.
Conv
size: 3, dilation: 1,
bias: False
Cond. BN
bias: False
Upsample
Cond. BN
bias: False
Conv
size: 3, dilation: 2,
bias: False
Upsample
Conv
size: 1, dilation: 1,
bias: False
Cond. BN
bias: False
Conv
size: 3, dilation: 4,
bias: False
Cond. BN
bias: False
Conv
size: 3, dilation: 8,
bias: True
h z
ReLU
ReLU
ReLU
ReLU
(b) Generator residual block (GBlock).
Figure 3: The proposed generative model (a) resembles the GAN-TTS generator and consists of 7
GBlocks (b) that use convolutional layers of increasing dilation rates, nearest-neighbour upsampling
and conditional Batch Normalization. The number of channels is changed only in the block’s first
and shortcut convolutions; and the latter is only present if the block reduces the number of channels.
The residual blocks follow the same upsampling pattern as GAN-TTS.
non-linearity before the flower convolution; and (ii) switching from a kernel size 3 to a kernel size 1
convolution; both led to more stable training with default settings. Addition of the former is inspired
by the BigGAN architecture [5] that GAN-TTS is based on; and the latter relies on an interpretation
of the first convolution as an embedding layer for the sparse conditioning linguistic features. These
differences are reflected in the generator architecture in Figure 4a.
Discriminator architecture. Empirically we found that it was necessary to introduce more changes
to the discriminator architecture. Specifically, the following alterations were made (see also Figure 4b
and Figure 4c):
• The mean-pooling along time and channel axes of the output of the final DBlock was replaced
by a non-linearity, followed by sum-pooling along the time axis and a dense linear projection
to obtain a scalar output. Like the addition of batch normalization and non-linearity before
the generator output, this change is inspired by the BigGAN architecture.
• Instead of a single random slice of the input waveforms, each discriminator sampled two
random slices (x1, c1) and (x2, c2), and produced independent outputs d1 and d2 for each
of them. These outputs were later averaged to produce discriminators final output d.
16
Stem Conv
size: 1, ch: 768,
bias: True
c
GBlock
ch: 768
GBlock
ch: 768
GBlock
ch: 384, up: 2x
GBlock
ch: 384, up: 2x
GBlock
ch: 384, up: 2x
GBlock
ch: 192, up: 3x
GBlock
ch: 96, up: 5x
Flower Conv
size: 3, ch: 1,
bias: True
ReLU
tanh
x
z
Uncond. BN
(a) Generator.
x2
d2
Reshape
[240, 15]
DBlock
ch: 64
DBlock
ch: 128, down: 2x
DBlock
ch: 256, down: 2x
Cond. DBlock
ch: 512, down: 2x
DBlock
ch: 512
Linear
ReLU
Sum pool
axis: time
Random slice
window: 3600
x c
x1
c1
d1
DBlock
ch: 512
c2
d
(b) Conditional discriminator.
Conv
size: 3, dilation: 1,
bias: True
Downsample
Conv
size: 3, dilation: 2,
bias: True
Downsample
Conv
size: 1, dilation: 1,
bias: True
h c
ReLU
ReLU
Conv
size: 1, dilation: 1,
bias: True
(c) Conditional discriminator residual block
(DBlock).
Figure 4: Architectures used in our implementation of GAN-TTS. Generator (a) makes use of a
smaller kernel size 1 convolution in the stem embedding linguistic features c and GBlocks identical
to those in Figure 3. Discriminator (b) replaces mean-pooling with an additional non-linearity,
sum-pooling and a final projection layer to obtain the scalars d1,2 for each of the two random slices
it samples. The random slice block takes aligned random crops (same for every example in the
minibatch) x1,2 and c1,2 of the waveform x and conditioning features c, and the outputs for each of
the two slices are averaged to obtain the final output d =
1
2
(d1 + d2). Example architecture is shown
for a conditional discriminator with window size 3600, but the same changes are applied to other
window sizes and unconditional discriminators. The modified (conditional) DBlock (c) re-orders the
first non-linearity and downsampling blocks.
• Inspired by the open source implementation of BigGAN1
, the structure of the first DBlock
of each discriminator was altered to not include the first non-linearity. The architecture was
surprisingly sensitive to this detail.
• Finally, the structure of the DBlocks was modified by (i) switching the order of the downsampling and non-linearity operations; and (ii) by reducing the dilation of the second convolution
to 1 when the time dimension of the block is less or equal to 16.
Hyper-parameters. We recap all hyper-parameters used in our re-implementation of GAN-TTS
in Table 6. As in the original publication, the GAN-TTS baseline was trained on a Cloud TPUs v3
with 128-way data parallelism and cross-replica Batch Normalization; training a single model took
approximately 48 hours.
Training curves for our implementation of GAN-TTS, and how they compare to a similar (simplified)
generator trained with the GED loss is shown in Figure 6.
1
See https://github.com/ajbrock/BigGAN-PyTorch
17
0k
50k
100k
150k
200k
250k
300k
350k
400k
450k
500k
550k
600k
650k
700k
750k
800k
850k
900k
950k
1000k
Steps
10
1
10
0
10
1
10
2
cFDSD
GAN-TTS, -transform: none
GAN-TTS, -transform: 8-bit
GAN-TTS, -transform: 16-bit
GED
Figure 6: GAN-TTS baseline (our implementation) with and without µ-transform; and GED
convergence speed and training stability.
Table 6: Hyper-parameters used in our implementation of the GAN-TTS baseline.
HYPER-PARAMETER VALUE
Optimizer Adam [17]
Adam β1 0
Adam β2 0.999
Adam  10−6
Generator learning rate 5 × 10−5
Discriminator learning rate 10−4
Learning rate schedule Linear warmup over 6000 steps
Loss Hinge [24]
Initialization Orthogonal [31]
Generator EMA decay rate 0.9999
Batch Normalization  10−4
Batch Normalization momentum 0.99
Spectral Normalization  10−4
Batch size 1024
Training steps 106
E.1 Fréchet Deep Speech Distances
At the time of writing no open source implementation of the Fréchet Deep Speech Distance (FDSD)
metrics [3] was available. We thus resorted to re-implementating these metrics based on the information provided in the original publication. While striving to reproduce the original implementation as
closely as possible, we deviated from it in at least two aspects, as discussed below.
Following the notation of Binkowski et al. ´ [3], let a ∈ R
48000 be a vector representing two seconds
of (synthesized) waveform at 24 kHz; DS(a) ∈ R
1600 be the sought representation that will be used
for computing the (conditional) FDSD; and fkω : R
kω 7→ R
d
k
2
e×1600 be a function that takes (a part
of) the waveform a and passes it through the pre-trained Deep Speech 2 (DS2) network [1, 21] to
obtain the necessary activations. The representation DS(a) used for computing the Fréchet distance
is then obtained by averaging the outputs of f across time.
1. Equation (4) in Appendix B.1 of Binkowski et al. ´ [3] implies that the necessary activations
were obtained independently for windows of the waveform a with window size ω = 480
and step ω
2 = 240 (20ms and 10ms at 24kHz respectively), resulting 199 activation vectors
18
of size 1600 each, which were then averaged to obtain the representation DS(a). Doing so
would not make any use of the DS2 bi-directional GRU layers, as their inputs would have
time dimensionality of 1 - a single frame of the STFT with frame length ω and step ω
2
. So
instead we used the entire audio fragment a (200 STFT frames) at once to obtain activations
f48000(a) ∈ R
100×1600 that were averaged along the time axis to obtain DS(a).
2. Binkowski et al. ´ [3] proposed using activations from the node labeled
ForwardPass/ds2_encoder/Reshape_2 in the graph of a pre-trained DS2 network to obtain activations fkω. This graph node belongs to the training pass of the model,
and uses 6 layers with 0.5 dropout probability (one after each of the 5 GRU layers, and then
again after the last fully-connected layer of the encoder network), resulting very sparse
activations. To make better use of the learned representations, we instead used the graph
node labeled ForwardPass_1/ds2_encoder/Reshape_2, which implements the test
time behaviour of the same network and produces dense activations.
The rest of the implementation followed Binkowski et al. ´ [3]. Namely, FDSD were estimated using
10000 samples from the training data, matching the conditioning signals between the two sets in the
case of conditional FDSD (cFDSD).
We tested our implementation by computing the FDSD for natural speech - the only quantity from
Binkowski et al. ´ [3] that can be reproduced without access to a trained generator, and found that
despite the implementation differences it agrees surprisingly well with the previously reported number
(ours: 0.143 vs. Binkowski et al. ´ [3]: 0.161). We also considered implementations of the FDSD that
did not deviate from the original description (i.e. using dropout and/or obtaining activations for each
window independently), but found that they had worse agreement with the previously reported natural
speech FDSD.
Without access to the original implementation it is impossible to tell whether there are other differences between the two FDSD implementations, or whether the described differences are actually
there - the two implementations agree unexpectedly well on natural speech FDSD despite significant
discrepancies in how they extract representations from the pre-trained model.
We hope that the difficulties we faced reproducing these results will prompt the research community
to open-source evaluation metrics early on, even in cases when the models themselves cannot be
made publicly available. We provide our implementation of FDSD in our github repository at
https://github.com/google-research/google-research/tree/master/ged_tts.
Appendix F Mean Opinion Scores
Each evaluator, a native North American English speaker paid to perform the task was asked to rate
the subjective naturalness of a sentence on a 1-5 (Bad-Excellent) Likert scale. Mean Opinion Scores
(MOS) were obtained by summarizing as mean and standard deviation the 1000 audio sample ratings
produced by at least 80 different human evaluators per test. The resulting scores are comparable
between between the models trained in this work, but may not be directly comparable with previous
work due to differences in composition of human evaluators and the evaluation instructions given to
them.
Appendix G Linguistic features
As in [3, 15, 35, 36], synthesized speech was conditioned on local linguistic features and pitch
information predicted from text using separate models; and ground truth linguistic features and pitch
were used during training.
19